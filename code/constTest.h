#ifndef CONSTTEST_H_
#define CONSTTEST_H_
#include "MyLib.h"

class Myconst
{
public:
	Myconst();
	~Myconst();
	static int ap;

};

/************************************************************************/
/*                             类中使用const						   */
/************************************************************************/

/*
在一个类中，任何不会修改数据成员的函数都应该声明为const类型。
如果在编写const成员函数时，不慎修改 数据成员，或者调用了其它非const成员函数，编译器将指出错误

使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象

const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.
*/

class Apple {
private: 
	int people[100];
public:
	Apple(int i);
	const int apple_num;
	void take(int num) const;//声明为const类型。
	int add(int num);
	int add(int num) const;
	int getCount() const;

};


void ConstFunc();

/************************************************************************/
/*                   //const修饰函数返回值								*/
/************************************************************************/


// 本身无意义，因为参数返回本身就是赋值给其他的变量！
const int func1();

// 指针指向的内容不变
const int *func2();

// 指针本身不变
int *const func3();

/************************************************************************/
/*                        const修饰函数参数								 */
/************************************************************************/
//(1)传递过来的参数及指针本身在函数内不可变，无意义！
//var本身就是形参，在函数内不会改变,采用“值传递”，

void func(const int var); // 传递过来的参数不可变
void func(int *const var); // 指针本身不可变

//（2）参数指针所指内容为常量不可变
//如果函数体内的语句试图改动src的内容，编译器将指出错
void StringCopy(char *dst, const char *src);

//（3）参数为引用，为了增加效率同时防止修改。


/*对于非内部数据类型的参数而言，象void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，
而临时对象的构造、复制、析构过程都将消耗时间。
为了提高效率，可以将函数声明改为void func(A &a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临 时对象。

“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加 const 修饰即可

是否应将void func(int x) 改写为void func(const int &x),完全没有必要，因为内部数
据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。

*/
void func(const Myconst &a);


#endif